<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>02_React_함수</title>
</head>

<body>
    <script>
        /* 
            데이터 유형
                1. number -> ""묶으면 문자열이 된다.
                    예) 10
                2. string -> "" 또는 ''로 반드시 묶는다.
                    예) "10"
                3. boolean: true, false
                4. undefined -> 변수를 선언하고 값을 할당하지 않았을 경우의 값
                5. object: 배열, null
                6. function


            연산자
                typeof -> 데이터 유형을 확인
                    예) typeof({ 123 }) 이런거 넣으면 위 데이터 유형중 어떤건지 확인해주는 것
        */
        /* 
            식별사(변수 이름, 함수 이름) 지정
                1. 첫 글자 영문자, _, $
                    - $var
                2. 영문의 대소문자 구별
                3. 예약어는 이름으로 사용하면 안된다.
                    예) var, const, let, finction, true, fasle, ...,

            참고
                상수(constant): 변하지 않는 값.

            변수(variable)? 저장 공간
                일반적으로 const로 선언하고 값 변경이 필요할 경우 let으로 선언한다.

            undefined 할당되었으나 값은 없다.


            함수(function)? 기능, 동작가진 저장 공간, 보관 -> 호출하면 동작한다.

                1. 선언적 함수
                2. 익명 함수
                3. 화살표 함수
                    단, 익명 함수만 화살표 함수로 변환가능하다.
                    -> 익명 함수를 보다 더 적게 쓰기 위함

                선언적 함수는 호이스팅 기능이 있다.
                    -> 호출 후 선언 가능
                    -> 호출문이 선언문 보다 위에 있어도 호출이 된다.
                익명 함수만 화살표 함수로 변경 가능하다.

            Syntax(구문, 통사론) Error -> 문법 에러, 규칙 에러

            함수 선언

                function 함수(para1, para2, ...,){
                    ...,
                }

                키워드 변수 = function(para1, para2, ...,) {};

                키워드 변수 = (para1, para2, ...,) => {};

            함수 호출

                함수(arg1, arg2, ...,);
                변수(arg1, arg2, ...,);

                parameter variable(매개 변수) -> 변수
                argument(인수, 인자) -> 값

            return 키워드 -> 반환, 블록을 벗어남 호출하면 그대로 끝이다
                예) finction fn(a,b) {
                    return;
                } // 이렇게 있으면 a,b고 뭐고 그대로 끝이라고 한다.


                그래서 이걸 이용해서 계산기도 제작할 수 있다고 한다.
                예) finction fn(a,b) {
                    return a + b;
                } // 이런식으로

                

            [화살표 함수]
                1. 함수에 명령문이 하나뿐이고 명령문이 값을 반환하는 경우
                    대괄호({})와 키워드를 제거할 수 있습니다.
                    
                2. 매개변수가 하나뿐인 경우 괄호를 건너뛸 수도 있습니다.


            1. 함수에 명령문이 하나뿐이고 명령문이 값을 반환하는 경우 대괄호 와 키워드 를 제거할 수 있습니다

            2. 매개변수가 하나뿐인 경우 괄호를 건너뛸 수도 있습니다.

        */

        // 문장 끝은 ;로 끝난다. 단, 제어문과 선언적 함수는 제외

        /* ---------------------------------------------------- */

        // 선언적 함수 -> 함수의 이름이 있다 -> fn
        function fn() {
            console.log("나는 선언적 함수이다.");
        };

        // 익명 함수 -> 함수의 이름이 없다. -> 변수에 저장하여 쓴다.
        const var1 = function () {
            console.log("나는 익명 함수이다.");
        };

        // 화살표 함수 -> 익명 함수를 간략화
        /* 
            const var2 = (a)=> {
                console.log(a);
            }
        */
        // 1. {} 안에 문장이 1개이면 -> {} 생략 / 개발자는 무조건 생략
        // const var2 = (a)=> console.log(a);

        // 2. 매개변수가 1개이면 -> () 생략
        // const var2 = a => console.log(a);

        // 3. 매개변수가 2개이면 () 필요
        const var2 = (a, b) => console.log(a);

        // 정규식(RegExp, Regular Expression)
        // \n -> 줄바꿈

        // + 연산자는
        console.log(fn() + '\n' + var1 + '\n' + var2 + '\n');
        document.write(fn() + '<br>' + var1 + '<br>' + var2 + '<br>');

        /* --------------------------------------------------------------------------- */
        // 함수 선언 -> 기능, 동작(시간), 저장공간 / 기능이 있는 저장 공간
        /* --------------------------------------------------------------------------- */


        /* --------------------------------------------------------------------------- */
        // 함수 호출 
        /* --------------------------------------------------------------------------- */
        fn();
        var1();
        var2();

        // ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

        // 매개 변수 개수보다 적게 인수를 써도 에러는 아니다.
        // 인수가 없는 매개 변수 값은 undefined -> 에러는 아니어도 개수를 맞춰 적용할것!

        fn("1." + "나는 선언적 함수이다.");
        var1("2." + "나는 익명 함수이다.");
        var2("3." + "나는 화살표 함수이다.");
        fn(1.1, 5);
        var1(2, 5);

        // 매개 변수 개수보다 더 많은 인수를 써도 에러는 아니다.
        // 매개 변수 개수 만큼 기록된 인수 순서로 적용된다.
        var2("3.", 5);

        console.log(var2("3.", 5));

        document.write(fn(1.1, 5)); // 6.1
        document.write(var1(2, 5)); // 7
        document.write(var2("3.", 5)); // 3.
        const x = fn(1.1, 5); // 6.1
        const y = var1(2, 5); // 7
        const z = var2("3.", 5); // 3.

        // 출력
        document.write(`x는 ${x} <br> y는 ${y} <br>z는 ${z} <br>`);
    </script>
</body>

</html>